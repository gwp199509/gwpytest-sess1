磁盘管理  mbr gpt
 mbr：大于2tb只识别2tb，最多4个主分区，区分主，扩展，逻辑  fdisk/parted
 gpt：支持大容量，主分区无限使用   gfdisk/parted
 MBR：每一块硬盘上存放磁盘引导程序，在磁盘开头部分，用于引导系统启动
  位置：磁盘分区表，0磁头，0磁道，1扇区(512字节)
    前446字节记录主引导mbr所在地，后64字节记录分区表，最后2字节为分区结束标识
	最多4个分区，主分区
	扩展分区，无法直接使用，需要在扩展分区下面创建逻辑分区后才能存放数据。
	逻辑分区，在扩展分区下创建，存放数据
  命名：sd sas/sata/scsi接口的硬盘  vd 虚拟机/公有云
  主分区或扩展分区1-4范围，逻辑分区从5开始
  /dev/sda1
1,分区三部曲：分区，创建文件系统(格式化)，挂载:给设备设置入口，不挂载，设备无法访问
  分区  fdisk -l 查看
       fdisk /dev/sdb  p 输出分区 n 创建分区 d删除分区，w保存分区 q退出分区
  格式化即创建文件系统  mkfs.xfs /dev/sdb  -f强制 xfs、ext4、ext2..
  挂载 mount /dev/sdb1 /data1  临时挂载    umount /data1  卸载
	 永久挂载 /etc/fstab  或  mount /dev/sdb1 /data 写入到/etc/rc.local
	 /dev/mapper/centos-root /   xfs     defaults        0 0
	 设备名或uuid 	挂载点	文件系统类型	一般defaults 是否备份 是否检查
	   blkid查看uuid
2，swap交换分区：内存不足时临时充当内存，占用磁盘空间
  增加1g swap   创建1g的文件，转换为swap，激活swap，加入到linux中，配置永久挂载
   dd if=/dev/zero of=/tmp/1g bs=1M count=1000 if输入文件，/dev/zero空文件  创建的文件 每次读多少 次数
   mkswap /tmp/1g 
   swapon /tmp/1g    chmod 600 /tmp/1g 数据安全考虑    swapoff /tmp/1g 关闭
   /etc/rc.local   /etc/fstab
3,磁盘空间不足 block不足
	du -sh /*   du sh /var/log/* .. 直到找到大文件，确认是否可以删除
  磁盘空间不足  inode不足，大量小文件
    df -i   find /gwp/ -type d -size +1M   找出大于1M的目录，确认是否可以删除
4，特殊符号“” ‘’ ``
	``优先执行反引号里面的命令
	‘’单引号里面的内容会原封不动输出
	“”类似单引号，对双引号里面的特殊符号进行解析
	不加引号  类似双引号，额外支持通配符
	1> 2>>  0标准输入，1标准输出，2标准错误输出
     echo oldboy >> oldboy.txt 2>&1或 &>>oldboy.txt 无论对错都追加到文件中
	 cat >>文件<<EOF   内容     
	 EOF
	{}输出序列
	？任意一个字符
	*所有
	[]参考正则中含义即可
	[!][^] 取反
5，正则表达式 
	基础正则 ^ $  . * .* [] [^] 
	扩展正则 | () + {} ?
	  ^x 以x开头
	  x$ 以x结尾  cat -A 可以显示隐藏的特殊符号
	  ^$ 空行
	  . 任意一个字符  grep -o 显示执行过程
	  \ 转义字符，去掉特殊符号的含义
	  * 前一个字符出现0次或0次以上
	  .* 所有
	  [abc] 匹配a或b或c中任意1个，[]单个匹配   [^abc]不匹配a或b或c
	 egrep 或 grep -E   sed -r  awk默认支出扩展正则
	  + 前一个字符连续出现1次或1次以上  常用[]连用 egrep -o '[1-9]+' test.txt
	  | 或  egrep 'oldboy|linux' test.txt 
	  () 表示一个整体，或在sed中实现后向引用 egrep '^(tree|vim)' == egrep '^tree|^vim'
	  {} x{m,n}连续出现至少m次，最多n次 x{n}连续出现n次 x{n,}连续出现至少n次  x{,m} 连续出现最多m次
	  ？ 前一个字符出现0次或1次
6，sed 取行、过滤、替换修改文件内容、后向引用(截取)
	-n 取消默认输出  sed -n '3p' test.txt '2,5p'2到5行，'/^root/p'//中间支持基础正则
		'/x/,/y/p' 从x到y，
	-r sed支持扩展正则
	-i 修改文件内容，这个选项放在最后
	-i.bak 先进行备份，然后修改内容，这个选项放在最后
	sed 's#x#y#g' test.txt  把x替换成y，只输出，并没修改文件 's/x/y/g'  s替换 g全局替换，不加只替换第一个
	sed -i 's#x#y#g' test.txt 把x替换成y，并修改文件
	sed -i.bak 's#x#y#g' test.txt  先备份test.txt.bak，再替换修改文件
	后向引用或反向引用：sed命令处理/提取一行中的某一部分，sed命令配合正则取列
	echo 12345678 | sed -r 's#(1)(.*)(8)#\1<\2>\3#g'   小括号分组，\数字引用分组
	sed -r 's#^(.*)(:x.*:)(.*$)#\3\2\1#g' passwd   交换第一列和最后一列
	ip a s eth0 | sed -n '3p' | sed -r 's#^.*et (.*)/.*$#\1#g' 提取ip地址
	删除  sed '3d' passwd  删除第三行
		egrep -v '^$|#' passwd
		sed -r '/^$|#/d' passwd
		awk '! /^$|#' passwd
	增加 a在指定行后面追加  i在指定行上面插入一行 c替换指定行的内容
		sed '3a/i/c gwp123' test.txt
7,awk 
	取行：awk 'NR==1{print $0}' passwd   print $0默认操作
	    awk 'NR>=2 && NR<5' passwd   范围 || 或  && 且
		awk '/root|gwp/' passwd  取出包含root或gwo的行
		awk '/root/ , /gwp/' passwd  取出从root到gwp的行
	取列：ll -h | awk '{print $5,$9}'   $数字代表列 $0一整行 $NF最后一列 $(NF-1)倒数第二列 | colum -t 对齐操作
		默认空格分割，-F 指定分隔符
		awk -F ':' '{print $1,$3,$NF}' passwd 
		ip a s eth0 | awk 'NR==3' | awk -F '[ /]+' '{print $3}'
	取行+取列 ip a s eth0 | awk -F '[ /]+' 'NR==3{print $3}'
		awk -F ':' '$3>900{print $1,$3,$NF}' passwd   取出第三列大于900的行的第一列、第三列、最后一列
		free | awk -F '[ ]+' '/Swap/ && $3==0{print "系统正常，未开始占用swap"}'  判断是否使用swap
		awk -F ':' '$4 ~ /^[01]/ {print $1,$3,$4}' passwd   ~对某一列过滤,包含 ！~不包含
	统计和计算
	  类似wc -l统计次数
	    awk '{i=i+1} END{print i}' passwd   统计行数
	  进行求和，累加
		awk '{i=i+$1}END{print i}' add.txt  累加
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
	
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	  
	















